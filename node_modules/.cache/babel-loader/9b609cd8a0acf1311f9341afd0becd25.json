{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\n\nfunction factory(file) {\n  var value = String(file);\n  var indices = [];\n  var search = /\\r?\\n|\\r/g;\n\n  while (search.exec(value)) {\n    indices.push(search.lastIndex);\n  }\n\n  indices.push(value.length + 1);\n  return {\n    toPoint: offsetToPoint,\n    toPosition: offsetToPoint,\n    toOffset: pointToOffset\n  }; // Get the line and column-based `point` for `offset` in the bound indices.\n\n  function offsetToPoint(offset) {\n    var index = -1;\n\n    if (offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (indices[index - 1] || 0) + 1,\n            offset: offset\n          };\n        }\n      }\n    }\n\n    return {};\n  } // Get the `offset` for a line and column-based `point` in the bound\n  // indices.\n\n\n  function pointToOffset(point) {\n    var line = point && point.line;\n    var column = point && point.column;\n    var offset;\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      offset = (indices[line - 2] || 0) + column - 1 || 0;\n    }\n\n    return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;\n  }\n}","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/vfile-location/index.js"],"names":["module","exports","factory","file","value","String","indices","search","exec","push","lastIndex","length","toPoint","offsetToPoint","toPosition","toOffset","pointToOffset","offset","index","line","column","point","isNaN"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAIC,KAAK,GAAGC,MAAM,CAACF,IAAD,CAAlB;AACA,MAAIG,OAAO,GAAG,EAAd;AACA,MAAIC,MAAM,GAAG,WAAb;;AAEA,SAAOA,MAAM,CAACC,IAAP,CAAYJ,KAAZ,CAAP,EAA2B;AACzBE,IAAAA,OAAO,CAACG,IAAR,CAAaF,MAAM,CAACG,SAApB;AACD;;AAEDJ,EAAAA,OAAO,CAACG,IAAR,CAAaL,KAAK,CAACO,MAAN,GAAe,CAA5B;AAEA,SAAO;AACLC,IAAAA,OAAO,EAAEC,aADJ;AAELC,IAAAA,UAAU,EAAED,aAFP;AAGLE,IAAAA,QAAQ,EAAEC;AAHL,GAAP,CAXqB,CAiBrB;;AACA,WAASH,aAAT,CAAuBI,MAAvB,EAA+B;AAC7B,QAAIC,KAAK,GAAG,CAAC,CAAb;;AAEA,QAAID,MAAM,GAAG,CAAC,CAAV,IAAeA,MAAM,GAAGX,OAAO,CAACA,OAAO,CAACK,MAAR,GAAiB,CAAlB,CAAnC,EAAyD;AACvD,aAAO,EAAEO,KAAF,GAAUZ,OAAO,CAACK,MAAzB,EAAiC;AAC/B,YAAIL,OAAO,CAACY,KAAD,CAAP,GAAiBD,MAArB,EAA6B;AAC3B,iBAAO;AACLE,YAAAA,IAAI,EAAED,KAAK,GAAG,CADT;AAELE,YAAAA,MAAM,EAAEH,MAAM,IAAIX,OAAO,CAACY,KAAK,GAAG,CAAT,CAAP,IAAsB,CAA1B,CAAN,GAAqC,CAFxC;AAGLD,YAAAA,MAAM,EAAEA;AAHH,WAAP;AAKD;AACF;AACF;;AAED,WAAO,EAAP;AACD,GAlCoB,CAoCrB;AACA;;;AACA,WAASD,aAAT,CAAuBK,KAAvB,EAA8B;AAC5B,QAAIF,IAAI,GAAGE,KAAK,IAAIA,KAAK,CAACF,IAA1B;AACA,QAAIC,MAAM,GAAGC,KAAK,IAAIA,KAAK,CAACD,MAA5B;AACA,QAAIH,MAAJ;;AAEA,QAAI,CAACK,KAAK,CAACH,IAAD,CAAN,IAAgB,CAACG,KAAK,CAACF,MAAD,CAAtB,IAAkCD,IAAI,GAAG,CAAP,IAAYb,OAAlD,EAA2D;AACzDW,MAAAA,MAAM,GAAG,CAACX,OAAO,CAACa,IAAI,GAAG,CAAR,CAAP,IAAqB,CAAtB,IAA2BC,MAA3B,GAAoC,CAApC,IAAyC,CAAlD;AACD;;AAED,WAAOH,MAAM,GAAG,CAAC,CAAV,IAAeA,MAAM,GAAGX,OAAO,CAACA,OAAO,CAACK,MAAR,GAAiB,CAAlB,CAA/B,GAAsDM,MAAtD,GAA+D,CAAC,CAAvE;AACD;AACF","sourcesContent":["'use strict'\n\nmodule.exports = factory\n\nfunction factory(file) {\n  var value = String(file)\n  var indices = []\n  var search = /\\r?\\n|\\r/g\n\n  while (search.exec(value)) {\n    indices.push(search.lastIndex)\n  }\n\n  indices.push(value.length + 1)\n\n  return {\n    toPoint: offsetToPoint,\n    toPosition: offsetToPoint,\n    toOffset: pointToOffset\n  }\n\n  // Get the line and column-based `point` for `offset` in the bound indices.\n  function offsetToPoint(offset) {\n    var index = -1\n\n    if (offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (indices[index - 1] || 0) + 1,\n            offset: offset\n          }\n        }\n      }\n    }\n\n    return {}\n  }\n\n  // Get the `offset` for a line and column-based `point` in the bound\n  // indices.\n  function pointToOffset(point) {\n    var line = point && point.line\n    var column = point && point.column\n    var offset\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      offset = (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return offset > -1 && offset < indices[indices.length - 1] ? offset : -1\n  }\n}\n"]},"metadata":{},"sourceType":"script"}