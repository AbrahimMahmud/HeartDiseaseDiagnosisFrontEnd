{"ast":null,"code":"/**\n * Escape carrigage returns like a terminal\n * @param {string} txt - String to escape.\n * @return {string}    - Escaped string.\n */\nfunction escapeCarriageReturn(txt) {\n  if (!txt) return \"\";\n  if (!/\\r/.test(txt)) return txt;\n  txt = txt.replace(/\\r+\\n/gm, \"\\n\"); // \\r followed by \\n --> newline\n\n  while (/\\r[^$]/.test(txt)) {\n    var base = /^(.*)\\r+/m.exec(txt)[1];\n    var insert = /\\r+(.*)$/m.exec(txt)[1];\n    insert = insert + base.slice(insert.length, base.length);\n    txt = txt.replace(/\\r+.*$/m, \"\\r\").replace(/^.*\\r/m, insert);\n  }\n\n  return txt;\n}\n\nfunction findLongestString(arr) {\n  var longest = 0;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[longest].length <= arr[i].length) {\n      longest = i;\n    }\n  }\n\n  return longest;\n}\n\nfunction escapeSingleLineSafe(txt) {\n  if (!/\\r/.test(txt)) return txt;\n  var arr = txt.split(\"\\r\");\n  var res = [];\n\n  while (arr.length > 0) {\n    var longest = findLongestString(arr);\n    res.push(arr[longest]);\n    arr = arr.slice(longest + 1);\n  }\n\n  return res.join(\"\\r\");\n}\n/**\n * Safely escape carrigage returns like a terminal.\n * This allows to escape carrigage returns while allowing future output to be appended\n * without loosing information.\n * Use this as a intermediate escape step if your stream hasn't completed yet.\n * @param {string} txt - String to escape.\n * @return {string}    - Escaped string.\n */\n\n\nfunction escapeCarriageReturnSafe(txt) {\n  if (!txt) return \"\";\n  if (!/\\r/.test(txt)) return txt;\n  if (!/\\n/.test(txt)) return escapeSingleLineSafe(txt);\n  txt = txt.replace(/\\r+\\n/gm, \"\\n\"); // \\r followed by \\n --> newline\n\n  var idx = txt.lastIndexOf(\"\\n\");\n  return escapeCarriageReturn(txt.slice(0, idx)) + \"\\n\" + escapeSingleLineSafe(txt.slice(idx + 1));\n}\n\nmodule.exports = escapeCarriageReturn;\nmodule.exports.escapeCarriageReturn = escapeCarriageReturn;\nmodule.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/escape-carriage/index.js"],"names":["escapeCarriageReturn","txt","test","replace","base","exec","insert","slice","length","findLongestString","arr","longest","i","escapeSingleLineSafe","split","res","push","join","escapeCarriageReturnSafe","idx","lastIndexOf","module","exports"],"mappings":"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","sourcesContent":["/**\n * Escape carrigage returns like a terminal\n * @param {string} txt - String to escape.\n * @return {string}    - Escaped string.\n */\nfunction escapeCarriageReturn(txt) {\n  if (!txt) return \"\";\n  if (!/\\r/.test(txt)) return txt;\n  txt = txt.replace(/\\r+\\n/gm, \"\\n\"); // \\r followed by \\n --> newline\n  while (/\\r[^$]/.test(txt)) {\n    var base = /^(.*)\\r+/m.exec(txt)[1];\n    var insert = /\\r+(.*)$/m.exec(txt)[1];\n    insert = insert + base.slice(insert.length, base.length);\n    txt = txt.replace(/\\r+.*$/m, \"\\r\").replace(/^.*\\r/m, insert);\n  }\n  return txt;\n}\n\nfunction findLongestString(arr) {\n  var longest = 0;\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[longest].length <= arr[i].length) {\n      longest = i;\n    }\n  }\n  return longest;\n}\n\nfunction escapeSingleLineSafe(txt) {\n  if (!/\\r/.test(txt)) return txt;\n  var arr = txt.split(\"\\r\");\n  var res = [];\n\n  while (arr.length > 0) {\n    var longest = findLongestString(arr);\n    res.push(arr[longest]);\n    arr = arr.slice(longest + 1);\n  }\n\n  return res.join(\"\\r\");\n}\n\n/**\n * Safely escape carrigage returns like a terminal.\n * This allows to escape carrigage returns while allowing future output to be appended\n * without loosing information.\n * Use this as a intermediate escape step if your stream hasn't completed yet.\n * @param {string} txt - String to escape.\n * @return {string}    - Escaped string.\n */\nfunction escapeCarriageReturnSafe(txt) {\n  if (!txt) return \"\";\n  if (!/\\r/.test(txt)) return txt;\n  if (!/\\n/.test(txt)) return escapeSingleLineSafe(txt);\n  txt = txt.replace(/\\r+\\n/gm, \"\\n\"); // \\r followed by \\n --> newline\n  var idx = txt.lastIndexOf(\"\\n\");\n\n  return (\n    escapeCarriageReturn(txt.slice(0, idx)) +\n    \"\\n\" +\n    escapeSingleLineSafe(txt.slice(idx + 1))\n  );\n}\n\nmodule.exports = escapeCarriageReturn;\nmodule.exports.escapeCarriageReturn = escapeCarriageReturn;\nmodule.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;\n"]},"metadata":{},"sourceType":"script"}