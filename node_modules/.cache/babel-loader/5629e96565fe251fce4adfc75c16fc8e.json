{"ast":null,"code":"'use strict';\n\nexports.unsafe = [{\n  character: '\\r',\n  inConstruct: ['mathFlowMeta']\n}, {\n  character: '\\r',\n  inConstruct: ['mathFlowMeta']\n}, {\n  character: '$',\n  inConstruct: ['mathFlowMeta', 'phrasing']\n}, {\n  atBreak: true,\n  character: '$',\n  after: '\\\\$'\n}];\nexports.handlers = {\n  math: math,\n  inlineMath: inlineMath\n};\ninlineMath.peek = inlineMathPeek;\n\nvar repeat = require('repeat-string');\n\nvar streak = require('longest-streak');\n\nvar safe = require('mdast-util-to-markdown/lib/util/safe');\n\nfunction math(node, _, context) {\n  var raw = node.value || '';\n  var fence = repeat('$', Math.max(streak(raw, '$') + 1, 2));\n  var exit = context.enter('mathFlow');\n  var value = fence;\n  var subexit;\n\n  if (node.meta) {\n    subexit = context.enter('mathFlowMeta');\n    value += safe(context, node.meta, {\n      before: '$',\n      after: ' ',\n      encode: ['$']\n    });\n    subexit();\n  }\n\n  value += '\\n';\n\n  if (raw) {\n    value += raw + '\\n';\n  }\n\n  value += fence;\n  exit();\n  return value;\n}\n\nfunction inlineMath(node) {\n  var value = node.value || '';\n  var size = 1;\n  var pad = '';\n  var sequence; // If there is a single dollar sign on its own in the math, use a fence of\n  // two.\n  // If there are two in a row, use one.\n\n  while (new RegExp('(^|[^$])' + repeat('\\\\$', size) + '([^$]|$)').test(value)) {\n    size++;\n  } // If this is not just spaces or eols (tabs don’t count), and either the first\n  // or last character are a space, eol, or dollar sign, then pad with spaces.\n\n\n  if (/[^ \\r\\n]/.test(value) && (/[ \\r\\n$]/.test(value.charAt(0)) || /[ \\r\\n$]/.test(value.charAt(value.length - 1)))) {\n    pad = ' ';\n  }\n\n  sequence = repeat('$', size);\n  return sequence + pad + value + pad + sequence;\n}\n\nfunction inlineMathPeek() {\n  return '$';\n}","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/mdast-util-math/to-markdown.js"],"names":["exports","unsafe","character","inConstruct","atBreak","after","handlers","math","inlineMath","peek","inlineMathPeek","repeat","require","streak","safe","node","_","context","raw","value","fence","Math","max","exit","enter","subexit","meta","before","encode","size","pad","sequence","RegExp","test","charAt","length"],"mappings":"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","sourcesContent":["'use strict'\n\nexports.unsafe = [\n  {character: '\\r', inConstruct: ['mathFlowMeta']},\n  {character: '\\r', inConstruct: ['mathFlowMeta']},\n  {character: '$', inConstruct: ['mathFlowMeta', 'phrasing']},\n  {atBreak: true, character: '$', after: '\\\\$'}\n]\n\nexports.handlers = {math: math, inlineMath: inlineMath}\n\ninlineMath.peek = inlineMathPeek\n\nvar repeat = require('repeat-string')\nvar streak = require('longest-streak')\nvar safe = require('mdast-util-to-markdown/lib/util/safe')\n\nfunction math(node, _, context) {\n  var raw = node.value || ''\n  var fence = repeat('$', Math.max(streak(raw, '$') + 1, 2))\n  var exit = context.enter('mathFlow')\n  var value = fence\n  var subexit\n\n  if (node.meta) {\n    subexit = context.enter('mathFlowMeta')\n    value += safe(context, node.meta, {before: '$', after: ' ', encode: ['$']})\n    subexit()\n  }\n\n  value += '\\n'\n\n  if (raw) {\n    value += raw + '\\n'\n  }\n\n  value += fence\n  exit()\n  return value\n}\n\nfunction inlineMath(node) {\n  var value = node.value || ''\n  var size = 1\n  var pad = ''\n  var sequence\n\n  // If there is a single dollar sign on its own in the math, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (\n    new RegExp('(^|[^$])' + repeat('\\\\$', size) + '([^$]|$)').test(value)\n  ) {\n    size++\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the first\n  // or last character are a space, eol, or dollar sign, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    (/[ \\r\\n$]/.test(value.charAt(0)) ||\n      /[ \\r\\n$]/.test(value.charAt(value.length - 1)))\n  ) {\n    pad = ' '\n  }\n\n  sequence = repeat('$', size)\n  return sequence + pad + value + pad + sequence\n}\n\nfunction inlineMathPeek() {\n  return '$'\n}\n"]},"metadata":{},"sourceType":"script"}