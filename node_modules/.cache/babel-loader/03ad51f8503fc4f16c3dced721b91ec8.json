{"ast":null,"code":"'use strict';\n\nexports.tokenize = tokenizeMathText;\nexports.resolve = resolveMathText;\nexports.previous = previous;\n\nfunction resolveMathText(events) {\n  var tailExitIndex = events.length - 4;\n  var headEnterIndex = 3;\n  var index;\n  var enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === 'lineEnding' || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === 'lineEnding') {\n      events[enter][1].type = 'mathTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 36 || this.events[this.events.length - 1][1].type === 'characterEscape';\n}\n\nfunction tokenizeMathText(effects, ok, nok) {\n  var self = this;\n  var sizeOpen = 0;\n  var size;\n  var token;\n  return start;\n\n  function start(code) {\n    /* istanbul ignore if - handled by mm */\n    if (code !== 36) throw new Error('expected `$`');\n    /* istanbul ignore if - handled by mm */\n\n    if (!previous.call(self, self.previous)) {\n      throw new Error('expected correct previous');\n    }\n\n    effects.enter('mathText');\n    effects.enter('mathTextSequence');\n    return openingSequence(code);\n  }\n\n  function openingSequence(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return openingSequence;\n    }\n\n    effects.exit('mathTextSequence');\n    return gap(code);\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    } // Closing fence?\n    // Could also be data.\n\n\n    if (code === 36) {\n      token = effects.enter('mathTextSequence');\n      size = 0;\n      return closingSequence(code);\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return gap;\n    }\n\n    if (code === -5 || code === -4 || code === -3) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return gap;\n    } // Data.\n\n\n    effects.enter('mathTextData');\n    return data(code);\n  } // In code.\n\n\n  function data(code) {\n    if (code === null || code === 32 || code === 36 || code === -5 || code === -4 || code === -3) {\n      effects.exit('mathTextData');\n      return gap(code);\n    }\n\n    effects.consume(code);\n    return data;\n  } // Closing fence.\n\n\n  function closingSequence(code) {\n    // More.\n    if (code === 36) {\n      effects.consume(code);\n      size++;\n      return closingSequence;\n    } // Done!\n\n\n    if (size === sizeOpen) {\n      effects.exit('mathTextSequence');\n      effects.exit('mathText');\n      return ok(code);\n    } // More or less accents: mark as data.\n\n\n    token.type = 'mathTextData';\n    return data(code);\n  }\n}","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/micromark-extension-math/lib/tokenize-math-text.js"],"names":["exports","tokenize","tokenizeMathText","resolve","resolveMathText","previous","events","tailExitIndex","length","headEnterIndex","index","enter","type","undefined","end","splice","code","effects","ok","nok","self","sizeOpen","size","token","start","Error","call","openingSequence","consume","exit","gap","closingSequence","data"],"mappings":"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","sourcesContent":["'use strict'\n\nexports.tokenize = tokenizeMathText\nexports.resolve = resolveMathText\nexports.previous = previous\n\nfunction resolveMathText(events) {\n  var tailExitIndex = events.length - 4\n  var headEnterIndex = 3\n  var index\n  var enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n\nfunction tokenizeMathText(effects, ok, nok) {\n  var self = this\n  var sizeOpen = 0\n  var size\n  var token\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - handled by mm */\n    if (code !== 36) throw new Error('expected `$`')\n\n    /* istanbul ignore if - handled by mm */\n    if (!previous.call(self, self.previous)) {\n      throw new Error('expected correct previous')\n    }\n\n    effects.enter('mathText')\n    effects.enter('mathTextSequence')\n    return openingSequence(code)\n  }\n\n  function openingSequence(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('mathTextSequence')\n    return gap(code)\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    }\n\n    // Closing fence?\n    // Could also be data.\n    if (code === 36) {\n      token = effects.enter('mathTextSequence')\n      size = 0\n      return closingSequence(code)\n    }\n\n    // Tabs don’t work, and virtual spaces don’t make sense.\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (code === -5 || code === -4 || code === -3) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    }\n\n    // Data.\n    effects.enter('mathTextData')\n    return data(code)\n  }\n\n  // In code.\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 36 ||\n      code === -5 ||\n      code === -4 ||\n      code === -3\n    ) {\n      effects.exit('mathTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n\n  // Closing fence.\n  function closingSequence(code) {\n    // More.\n    if (code === 36) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit('mathTextSequence')\n      effects.exit('mathText')\n      return ok(code)\n    }\n\n    // More or less accents: mark as data.\n    token.type = 'mathTextData'\n    return data(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}