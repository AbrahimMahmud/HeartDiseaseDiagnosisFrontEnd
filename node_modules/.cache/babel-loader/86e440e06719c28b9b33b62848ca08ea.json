{"ast":null,"code":"module.exports = safe;\n\nvar patternCompile = require('./pattern-compile');\n\nvar patternInScope = require('./pattern-in-scope');\n\nfunction safe(context, input, config) {\n  var value = (config.before || '') + (input || '') + (config.after || '');\n  var positions = [];\n  var result = [];\n  var infos = {};\n  var index = -1;\n  var before;\n  var after;\n  var position;\n  var pattern;\n  var expression;\n  var match;\n  var start;\n  var end;\n\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index];\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue;\n    }\n\n    expression = patternCompile(pattern);\n\n    while (match = expression.exec(value)) {\n      before = 'before' in pattern || pattern.atBreak;\n      after = 'after' in pattern;\n      position = match.index + (before ? match[1].length : 0);\n\n      if (positions.indexOf(position) === -1) {\n        positions.push(position);\n        infos[position] = {\n          before: before,\n          after: after\n        };\n      } else {\n        if (infos[position].before && !before) {\n          infos[position].before = false;\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false;\n        }\n      }\n    }\n  }\n\n  positions.sort(numerical);\n  start = config.before ? config.before.length : 0;\n  end = value.length - (config.after ? config.after.length : 0);\n  index = -1;\n\n  while (++index < positions.length) {\n    position = positions[index];\n\n    if ( // Character before or after matched:\n    position < start || position >= end) {\n      continue;\n    } // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n\n\n    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after) {\n      continue;\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'));\n    }\n\n    start = position;\n\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || config.encode.indexOf(value.charAt(position)) === -1)) {\n      // Character escape.\n      result.push('\\\\');\n    } else {\n      // Character reference.\n      result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');\n      start++;\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\n  return result.join('');\n}\n\nfunction numerical(a, b) {\n  return a - b;\n}\n\nfunction escapeBackslashes(value, after) {\n  var expression = /\\\\(?=[!-/:-@[-`{-~])/g;\n  var positions = [];\n  var results = [];\n  var index = -1;\n  var start = 0;\n  var whole = value + after;\n  var match;\n\n  while (match = expression.exec(whole)) {\n    positions.push(match.index);\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]));\n    }\n\n    results.push('\\\\');\n    start = positions[index];\n  }\n\n  results.push(value.slice(start));\n  return results.join('');\n}","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/mdast-util-to-markdown/lib/util/safe.js"],"names":["module","exports","safe","patternCompile","require","patternInScope","context","input","config","value","before","after","positions","result","infos","index","position","pattern","expression","match","start","end","unsafe","length","stack","exec","atBreak","indexOf","push","sort","numerical","escapeBackslashes","slice","test","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole"],"mappings":"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","sourcesContent":["module.exports = safe\n\nvar patternCompile = require('./pattern-compile')\nvar patternInScope = require('./pattern-in-scope')\n\nfunction safe(context, input, config) {\n  var value = (config.before || '') + (input || '') + (config.after || '')\n  var positions = []\n  var result = []\n  var infos = {}\n  var index = -1\n  var before\n  var after\n  var position\n  var pattern\n  var expression\n  var match\n  var start\n  var end\n\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      before = 'before' in pattern || pattern.atBreak\n      after = 'after' in pattern\n\n      position = match.index + (before ? match[1].length : 0)\n\n      if (positions.indexOf(position) === -1) {\n        positions.push(position)\n        infos[position] = {before: before, after: after}\n      } else {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  start = config.before ? config.before.length : 0\n  end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    position = positions[index]\n\n    if (\n      // Character before or after matched:\n      position < start ||\n      position >= end\n    ) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      position + 1 < end &&\n      positions[index + 1] === position + 1 &&\n      infos[position].after &&\n      !infos[position + 1].before &&\n      !infos[position + 1].after\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || config.encode.indexOf(value.charAt(position)) === -1)\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\nfunction numerical(a, b) {\n  return a - b\n}\n\nfunction escapeBackslashes(value, after) {\n  var expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  var positions = []\n  var results = []\n  var index = -1\n  var start = 0\n  var whole = value + after\n  var match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n"]},"metadata":{},"sourceType":"script"}