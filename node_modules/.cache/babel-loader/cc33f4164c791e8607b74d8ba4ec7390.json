{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\n\nvar convert = require('hast-util-is-element/convert');\n\nvar findAfter = require('unist-util-find-after');\n\nmodule.exports = toText;\nvar searchLineFeeds = /\\n/g;\nvar searchTabOrSpaces = /[\\t ]+/g;\nvar br = convert('br');\nvar p = convert('p');\nvar cell = convert(['th', 'td']);\nvar row = convert('tr'); // Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\n\nvar notRendered = convert([// List from: <https://html.spec.whatwg.org/#hidden-elements>\n'datalist', 'head', 'noembed', 'noframes', 'rp', 'script', 'style', 'template', 'title', // Act as if we support scripting.\n'noscript', // Hidden attribute.\nhidden, // From: <https://html.spec.whatwg.org/#flow-content-3>\nclosedDialog]); // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\nvar blockOrCaption = convert(['caption', // `table-caption`\n// Page\n'html', 'body', // Flow content\n'address', 'blockquote', 'center', // Legacy\n'dialog', 'div', 'figure', 'figcaption', 'footer', 'form,', 'header', 'hr', 'legend', 'listing', // Legacy\n'main', 'p', 'plaintext', // Legacy\n'pre', 'xmp', // Legacy\n// Sections and headings\n'article', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup', 'nav', 'section', // Lists\n'dir', // Legacy\n'dd', 'dl', 'dt', 'menu', 'ol', 'ul']); // Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\n\nfunction toText(node) {\n  var children = node.children || [];\n  var block = blockOrCaption(node);\n  var whiteSpace = inferWhiteSpace(node, {});\n  var index = -1;\n  var results;\n  var result;\n  var value;\n  var count; // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    });\n  } // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n  // 2.  Let results be a new empty list.\n\n\n  results = []; // 3.  For each child node node of this element:\n\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index ? null : block,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n    }));\n  } // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n\n\n  index = -1;\n  result = [];\n\n  while (++index < results.length) {\n    value = results[index];\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value;\n    } else if (value) {\n      if (count) result.push(repeat('\\n', count));\n      count = 0;\n      result.push(value);\n    }\n  } // 7.  Return the concatenation of the string items in results.\n\n\n  return result.join('');\n} // <https://html.spec.whatwg.org/#inner-text-collection-steps>\n\n\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options);\n  }\n\n  if (node.type === 'text') {\n    return [options.whiteSpace === 'normal' ? collectText(node, options) : collectPreText(node, options)];\n  }\n\n  return [];\n} // Collect an element.\n\n\nfunction collectElement(node, _, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options);\n  var children = node.children || [];\n  var index = -1;\n  var items = [];\n  var prefix;\n  var suffix; // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n\n  if (notRendered(node)) {\n    return items;\n  } // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n  // See `collectText` for step 4.\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n\n\n  if (br(node)) {\n    suffix = '\\n';\n  } // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n';\n  } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  } // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  } // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n\n\n  while (++index < children.length) {\n    items = items.concat(innerTextCollection(children[index], index, node, {\n      whiteSpace: whiteSpace,\n      breakBefore: index ? null : prefix,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n    }));\n  } // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n\n\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t');\n  } // Add the pre- and suffix.\n\n\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n} // 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n\n\nfunction collectText(node, options) {\n  var value = String(node.value);\n  var lines = [];\n  var result = [];\n  var start = 0;\n  var index = -1;\n  var match;\n  var end;\n  var join;\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start;\n    match = searchLineFeeds.exec(value);\n    end = match ? match.index : value.length;\n    lines.push( // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    trimAndcollapseSpacesAndTabs( // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n    // they were not there.\n    value.slice(start, end).replace(/[\\u061c\\u200e\\u200f\\u202a-\\u202e\\u2066-\\u2069]/g, ''), options.breakBefore, options.breakAfter));\n    start = end + 1;\n  } // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x200b\n    /* ZWSP */\n    || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x200b\n    /* ZWSP */\n    ) {\n      result.push(lines[index]);\n      join = '';\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join);\n      result.push(lines[index]);\n      join = ' ';\n    }\n  }\n\n  return result.join('');\n}\n\nfunction collectPreText(node) {\n  return String(node.value);\n} // 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\n\n\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var result = [];\n  var start = 0;\n  var match;\n  var end;\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    match = searchTabOrSpaces.exec(value);\n    end = match ? match.index : value.length; // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n\n    if (!start && !end && match && !breakBefore) {\n      result.push('');\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n\n    start = match ? end + match[0].length : end;\n  } // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n\n\n  if (start !== end && !breakAfter) {\n    result.push('');\n  }\n\n  return result.join(' ');\n} // We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n\n\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {};\n  var inherit = options.whiteSpace || 'normal';\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre';\n\n    case 'nobr':\n      return 'nowrap';\n\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre';\n\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit;\n\n    case 'textarea':\n      return 'pre-wrap';\n\n    default:\n      return inherit;\n  }\n}\n\nfunction hidden(node) {\n  return (node.properties || {}).hidden;\n}\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\n}","map":{"version":3,"sources":["/Users/abrahimmahmud/IdeaProjects/HeartDiseaseDiagnosisFrontEnd/node_modules/hast-util-to-text/index.js"],"names":["repeat","require","convert","findAfter","module","exports","toText","searchLineFeeds","searchTabOrSpaces","br","p","cell","row","notRendered","hidden","closedDialog","blockOrCaption","node","children","block","whiteSpace","inferWhiteSpace","index","results","result","value","count","type","collectText","breakBefore","breakAfter","length","concat","innerTextCollection","undefined","push","join","parent","options","collectElement","collectPreText","_","items","prefix","suffix","unshift","String","lines","start","match","end","lastIndex","exec","trimAndcollapseSpacesAndTabs","slice","replace","charCodeAt","props","properties","inherit","tagName","wrap","noWrap","open"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,8BAAD,CAArB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,uBAAD,CAAvB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,MAAjB;AAEA,IAAIC,eAAe,GAAG,KAAtB;AACA,IAAIC,iBAAiB,GAAG,SAAxB;AAEA,IAAIC,EAAE,GAAGP,OAAO,CAAC,IAAD,CAAhB;AACA,IAAIQ,CAAC,GAAGR,OAAO,CAAC,GAAD,CAAf;AACA,IAAIS,IAAI,GAAGT,OAAO,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,CAAlB;AACA,IAAIU,GAAG,GAAGV,OAAO,CAAC,IAAD,CAAjB,C,CAEA;AACA;;AACA,IAAIW,WAAW,GAAGX,OAAO,CAAC,CACxB;AACA,UAFwB,EAGxB,MAHwB,EAIxB,SAJwB,EAKxB,UALwB,EAMxB,IANwB,EAOxB,QAPwB,EAQxB,OARwB,EASxB,UATwB,EAUxB,OAVwB,EAWxB;AACA,UAZwB,EAaxB;AACAY,MAdwB,EAexB;AACAC,YAhBwB,CAAD,CAAzB,C,CAmBA;;AACA,IAAIC,cAAc,GAAGd,OAAO,CAAC,CAC3B,SAD2B,EAChB;AACX;AACA,MAH2B,EAI3B,MAJ2B,EAK3B;AACA,SAN2B,EAO3B,YAP2B,EAQ3B,QAR2B,EAQjB;AACV,QAT2B,EAU3B,KAV2B,EAW3B,QAX2B,EAY3B,YAZ2B,EAa3B,QAb2B,EAc3B,OAd2B,EAe3B,QAf2B,EAgB3B,IAhB2B,EAiB3B,QAjB2B,EAkB3B,SAlB2B,EAkBhB;AACX,MAnB2B,EAoB3B,GApB2B,EAqB3B,WArB2B,EAqBd;AACb,KAtB2B,EAuB3B,KAvB2B,EAuBpB;AACP;AACA,SAzB2B,EA0B3B,OA1B2B,EA2B3B,IA3B2B,EA4B3B,IA5B2B,EA6B3B,IA7B2B,EA8B3B,IA9B2B,EA+B3B,IA/B2B,EAgC3B,IAhC2B,EAiC3B,QAjC2B,EAkC3B,KAlC2B,EAmC3B,SAnC2B,EAoC3B;AACA,KArC2B,EAqCpB;AACP,IAtC2B,EAuC3B,IAvC2B,EAwC3B,IAxC2B,EAyC3B,MAzC2B,EA0C3B,IA1C2B,EA2C3B,IA3C2B,CAAD,CAA5B,C,CA8CA;AACA;AACA;AACA;;AACA,SAASI,MAAT,CAAgBW,IAAhB,EAAsB;AACpB,MAAIC,QAAQ,GAAGD,IAAI,CAACC,QAAL,IAAiB,EAAhC;AACA,MAAIC,KAAK,GAAGH,cAAc,CAACC,IAAD,CAA1B;AACA,MAAIG,UAAU,GAAGC,eAAe,CAACJ,IAAD,EAAO,EAAP,CAAhC;AACA,MAAIK,KAAK,GAAG,CAAC,CAAb;AACA,MAAIC,OAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,KAAJ,CARoB,CAUpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIT,IAAI,CAACU,IAAL,KAAc,MAAd,IAAwBV,IAAI,CAACU,IAAL,KAAc,SAA1C,EAAqD;AACnD,WAAOC,WAAW,CAACX,IAAD,EAAO;AACvBG,MAAAA,UAAU,EAAEA,UADW;AAEvBS,MAAAA,WAAW,EAAE,IAFU;AAGvBC,MAAAA,UAAU,EAAE;AAHW,KAAP,CAAlB;AAKD,GAxBmB,CA0BpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACAP,EAAAA,OAAO,GAAG,EAAV,CArCoB,CAuCpB;;AACA,SAAO,EAAED,KAAF,GAAUJ,QAAQ,CAACa,MAA1B,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACAR,IAAAA,OAAO,GAAGA,OAAO,CAACS,MAAR,CACRC,mBAAmB,CAACf,QAAQ,CAACI,KAAD,CAAT,EAAkBA,KAAlB,EAAyBL,IAAzB,EAA+B;AAChDG,MAAAA,UAAU,EAAEA,UADoC;AAEhDS,MAAAA,WAAW,EAAEP,KAAK,GAAG,IAAH,GAAUH,KAFoB;AAGhDW,MAAAA,UAAU,EACRR,KAAK,GAAGJ,QAAQ,CAACa,MAAT,GAAkB,CAA1B,GAA8BtB,EAAE,CAACS,QAAQ,CAACI,KAAK,GAAG,CAAT,CAAT,CAAhC,GAAwDH;AAJV,KAA/B,CADX,CAAV;AAQD,GAtDmB,CAwDpB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAG,EAAAA,KAAK,GAAG,CAAC,CAAT;AACAE,EAAAA,MAAM,GAAG,EAAT;;AAEA,SAAO,EAAEF,KAAF,GAAUC,OAAO,CAACQ,MAAzB,EAAiC;AAC/BN,IAAAA,KAAK,GAAGF,OAAO,CAACD,KAAD,CAAf;;AAEA,QAAI,OAAOG,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAIC,KAAK,KAAKQ,SAAV,IAAuBT,KAAK,GAAGC,KAAnC,EAA0CA,KAAK,GAAGD,KAAR;AAC3C,KAFD,MAEO,IAAIA,KAAJ,EAAW;AAChB,UAAIC,KAAJ,EAAWF,MAAM,CAACW,IAAP,CAAYnC,MAAM,CAAC,IAAD,EAAO0B,KAAP,CAAlB;AACXA,MAAAA,KAAK,GAAG,CAAR;AACAF,MAAAA,MAAM,CAACW,IAAP,CAAYV,KAAZ;AACD;AACF,GA5EmB,CA8EpB;;;AACA,SAAOD,MAAM,CAACY,IAAP,CAAY,EAAZ,CAAP;AACD,C,CAED;;;AACA,SAASH,mBAAT,CAA6BhB,IAA7B,EAAmCK,KAAnC,EAA0Ce,MAA1C,EAAkDC,OAAlD,EAA2D;AACzD,MAAIrB,IAAI,CAACU,IAAL,KAAc,SAAlB,EAA6B;AAC3B,WAAOY,cAAc,CAACtB,IAAD,EAAOK,KAAP,EAAce,MAAd,EAAsBC,OAAtB,CAArB;AACD;;AAED,MAAIrB,IAAI,CAACU,IAAL,KAAc,MAAlB,EAA0B;AACxB,WAAO,CACLW,OAAO,CAAClB,UAAR,KAAuB,QAAvB,GACIQ,WAAW,CAACX,IAAD,EAAOqB,OAAP,CADf,GAEIE,cAAc,CAACvB,IAAD,EAAOqB,OAAP,CAHb,CAAP;AAKD;;AAED,SAAO,EAAP;AACD,C,CAED;;;AACA,SAASC,cAAT,CAAwBtB,IAAxB,EAA8BwB,CAA9B,EAAiCJ,MAAjC,EAAyCC,OAAzC,EAAkD;AAChD;AACA,MAAIlB,UAAU,GAAGC,eAAe,CAACJ,IAAD,EAAOqB,OAAP,CAAhC;AACA,MAAIpB,QAAQ,GAAGD,IAAI,CAACC,QAAL,IAAiB,EAAhC;AACA,MAAII,KAAK,GAAG,CAAC,CAAb;AACA,MAAIoB,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAJ;AACA,MAAIC,MAAJ,CAPgD,CAShD;AACA;;AACA,MAAI/B,WAAW,CAACI,IAAD,CAAf,EAAuB;AACrB,WAAOyB,KAAP;AACD,GAb+C,CAehD;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;AACA,MAAIjC,EAAE,CAACQ,IAAD,CAAN,EAAc;AACZ2B,IAAAA,MAAM,GAAG,IAAT;AACD,GAFD,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA,OAYK,IAAIhC,GAAG,CAACK,IAAD,CAAH,IAAad,SAAS,CAACkC,MAAD,EAASpB,IAAT,EAAeL,GAAf,CAA1B,EAA+C;AAClDgC,IAAAA,MAAM,GAAG,IAAT;AACD,GAFI,CAIL;AACA;AALK,OAMA,IAAIlC,CAAC,CAACO,IAAD,CAAL,EAAa;AAChB0B,IAAAA,MAAM,GAAG,CAAT;AACAC,IAAAA,MAAM,GAAG,CAAT;AACD,GAHI,CAKL;AACA;AACA;AAPK,OAQA,IAAI5B,cAAc,CAACC,IAAD,CAAlB,EAA0B;AAC7B0B,IAAAA,MAAM,GAAG,CAAT;AACAC,IAAAA,MAAM,GAAG,CAAT;AACD,GA5D+C,CA8DhD;AACA;AACA;;;AACA,SAAO,EAAEtB,KAAF,GAAUJ,QAAQ,CAACa,MAA1B,EAAkC;AAChCW,IAAAA,KAAK,GAAGA,KAAK,CAACV,MAAN,CACNC,mBAAmB,CAACf,QAAQ,CAACI,KAAD,CAAT,EAAkBA,KAAlB,EAAyBL,IAAzB,EAA+B;AAChDG,MAAAA,UAAU,EAAEA,UADoC;AAEhDS,MAAAA,WAAW,EAAEP,KAAK,GAAG,IAAH,GAAUqB,MAFoB;AAGhDb,MAAAA,UAAU,EACRR,KAAK,GAAGJ,QAAQ,CAACa,MAAT,GAAkB,CAA1B,GAA8BtB,EAAE,CAACS,QAAQ,CAACI,KAAK,GAAG,CAAT,CAAT,CAAhC,GAAwDsB;AAJV,KAA/B,CADb,CAAR;AAQD,GA1E+C,CA4EhD;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAIjC,IAAI,CAACM,IAAD,CAAJ,IAAcd,SAAS,CAACkC,MAAD,EAASpB,IAAT,EAAeN,IAAf,CAA3B,EAAiD;AAC/C+B,IAAAA,KAAK,CAACP,IAAN,CAAW,IAAX;AACD,GApF+C,CAsFhD;;;AACA,MAAIQ,MAAJ,EAAYD,KAAK,CAACG,OAAN,CAAcF,MAAd;AACZ,MAAIC,MAAJ,EAAYF,KAAK,CAACP,IAAN,CAAWS,MAAX;AAEZ,SAAOF,KAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASd,WAAT,CAAqBX,IAArB,EAA2BqB,OAA3B,EAAoC;AAClC,MAAIb,KAAK,GAAGqB,MAAM,CAAC7B,IAAI,CAACQ,KAAN,CAAlB;AACA,MAAIsB,KAAK,GAAG,EAAZ;AACA,MAAIvB,MAAM,GAAG,EAAb;AACA,MAAIwB,KAAK,GAAG,CAAZ;AACA,MAAI1B,KAAK,GAAG,CAAC,CAAb;AACA,MAAI2B,KAAJ;AACA,MAAIC,GAAJ;AACA,MAAId,IAAJ;;AAEA,SAAOY,KAAK,GAAGvB,KAAK,CAACM,MAArB,EAA6B;AAC3BxB,IAAAA,eAAe,CAAC4C,SAAhB,GAA4BH,KAA5B;AACAC,IAAAA,KAAK,GAAG1C,eAAe,CAAC6C,IAAhB,CAAqB3B,KAArB,CAAR;AACAyB,IAAAA,GAAG,GAAGD,KAAK,GAAGA,KAAK,CAAC3B,KAAT,GAAiBG,KAAK,CAACM,MAAlC;AAEAgB,IAAAA,KAAK,CAACZ,IAAN,EACE;AACA;AACAkB,IAAAA,4BAA4B,EAC1B;AACA;AACA;AACA5B,IAAAA,KAAK,CACF6B,KADH,CACSN,KADT,EACgBE,GADhB,EAEGK,OAFH,CAEW,iDAFX,EAE8D,EAF9D,CAJ0B,EAO1BjB,OAAO,CAACT,WAPkB,EAQ1BS,OAAO,CAACR,UARkB,CAH9B;AAeAkB,IAAAA,KAAK,GAAGE,GAAG,GAAG,CAAd;AACD,GA/BiC,CAiClC;AACA;AACA;AACA;AACA;;;AACA,SAAO,EAAE5B,KAAF,GAAUyB,KAAK,CAAChB,MAAvB,EAA+B;AAC7B;AACA;AACA;AACA,QACEgB,KAAK,CAACzB,KAAD,CAAL,CAAakC,UAAb,CAAwBT,KAAK,CAACzB,KAAD,CAAL,CAAaS,MAAb,GAAsB,CAA9C,MAAqD;AAAO;AAA5D,OACCT,KAAK,GAAGyB,KAAK,CAAChB,MAAN,GAAe,CAAvB,IACCgB,KAAK,CAACzB,KAAK,GAAG,CAAT,CAAL,CAAiBkC,UAAjB,CAA4B,CAA5B,MAAmC;AAAQ;AAH/C,MAIE;AACAhC,MAAAA,MAAM,CAACW,IAAP,CAAYY,KAAK,CAACzB,KAAD,CAAjB;AACAc,MAAAA,IAAI,GAAG,EAAP;AACD,KAPD,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAxBA,SAyBK,IAAIW,KAAK,CAACzB,KAAD,CAAT,EAAkB;AACrB,UAAIc,IAAJ,EAAUZ,MAAM,CAACW,IAAP,CAAYC,IAAZ;AACVZ,MAAAA,MAAM,CAACW,IAAP,CAAYY,KAAK,CAACzB,KAAD,CAAjB;AACAc,MAAAA,IAAI,GAAG,GAAP;AACD;AACF;;AAED,SAAOZ,MAAM,CAACY,IAAP,CAAY,EAAZ,CAAP;AACD;;AAED,SAASI,cAAT,CAAwBvB,IAAxB,EAA8B;AAC5B,SAAO6B,MAAM,CAAC7B,IAAI,CAACQ,KAAN,CAAb;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS4B,4BAAT,CAAsC5B,KAAtC,EAA6CI,WAA7C,EAA0DC,UAA1D,EAAsE;AACpE,MAAIN,MAAM,GAAG,EAAb;AACA,MAAIwB,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAJ;AACA,MAAIC,GAAJ;;AAEA,SAAOF,KAAK,GAAGvB,KAAK,CAACM,MAArB,EAA6B;AAC3BvB,IAAAA,iBAAiB,CAAC2C,SAAlB,GAA8BH,KAA9B;AACAC,IAAAA,KAAK,GAAGzC,iBAAiB,CAAC4C,IAAlB,CAAuB3B,KAAvB,CAAR;AACAyB,IAAAA,GAAG,GAAGD,KAAK,GAAGA,KAAK,CAAC3B,KAAT,GAAiBG,KAAK,CAACM,MAAlC,CAH2B,CAK3B;AACA;;AACA,QAAI,CAACiB,KAAD,IAAU,CAACE,GAAX,IAAkBD,KAAlB,IAA2B,CAACpB,WAAhC,EAA6C;AAC3CL,MAAAA,MAAM,CAACW,IAAP,CAAY,EAAZ;AACD;;AAED,QAAIa,KAAK,KAAKE,GAAd,EAAmB;AACjB1B,MAAAA,MAAM,CAACW,IAAP,CAAYV,KAAK,CAAC6B,KAAN,CAAYN,KAAZ,EAAmBE,GAAnB,CAAZ;AACD;;AAEDF,IAAAA,KAAK,GAAGC,KAAK,GAAGC,GAAG,GAAGD,KAAK,CAAC,CAAD,CAAL,CAASlB,MAAlB,GAA2BmB,GAAxC;AACD,GAtBmE,CAwBpE;AACA;AACA;;;AACA,MAAIF,KAAK,KAAKE,GAAV,IAAiB,CAACpB,UAAtB,EAAkC;AAChCN,IAAAA,MAAM,CAACW,IAAP,CAAY,EAAZ;AACD;;AAED,SAAOX,MAAM,CAACY,IAAP,CAAY,GAAZ,CAAP;AACD,C,CAED;;;AACA,SAASf,eAAT,CAAyBJ,IAAzB,EAA+BqB,OAA/B,EAAwC;AACtC,MAAImB,KAAK,GAAGxC,IAAI,CAACyC,UAAL,IAAmB,EAA/B;AACA,MAAIC,OAAO,GAAGrB,OAAO,CAAClB,UAAR,IAAsB,QAApC;;AAEA,UAAQH,IAAI,CAAC2C,OAAb;AACE,SAAK,SAAL;AACA,SAAK,WAAL;AACA,SAAK,KAAL;AACE,aAAO,KAAP;;AACF,SAAK,MAAL;AACE,aAAO,QAAP;;AACF,SAAK,KAAL;AACE,aAAOH,KAAK,CAACI,IAAN,GAAa,UAAb,GAA0B,KAAjC;;AACF,SAAK,IAAL;AACA,SAAK,IAAL;AACE,aAAOJ,KAAK,CAACK,MAAN,GAAe,QAAf,GAA0BH,OAAjC;;AACF,SAAK,UAAL;AACE,aAAO,UAAP;;AACF;AACE,aAAOA,OAAP;AAfJ;AAiBD;;AAED,SAAS7C,MAAT,CAAgBG,IAAhB,EAAsB;AACpB,SAAO,CAACA,IAAI,CAACyC,UAAL,IAAmB,EAApB,EAAwB5C,MAA/B;AACD;;AAED,SAASC,YAAT,CAAsBE,IAAtB,EAA4B;AAC1B,SAAOA,IAAI,CAAC2C,OAAL,KAAiB,QAAjB,IAA6B,CAAC,CAAC3C,IAAI,CAACyC,UAAL,IAAmB,EAApB,EAAwBK,IAA7D;AACD","sourcesContent":["'use strict'\n\nvar repeat = require('repeat-string')\nvar convert = require('hast-util-is-element/convert')\nvar findAfter = require('unist-util-find-after')\n\nmodule.exports = toText\n\nvar searchLineFeeds = /\\n/g\nvar searchTabOrSpaces = /[\\t ]+/g\n\nvar br = convert('br')\nvar p = convert('p')\nvar cell = convert(['th', 'td'])\nvar row = convert('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nvar notRendered = convert([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Act as if we support scripting.\n  'noscript',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nvar blockOrCaption = convert([\n  'caption', // `table-caption`\n  // Page\n  'html',\n  'body',\n  // Flow content\n  'address',\n  'blockquote',\n  'center', // Legacy\n  'dialog',\n  'div',\n  'figure',\n  'figcaption',\n  'footer',\n  'form,',\n  'header',\n  'hr',\n  'legend',\n  'listing', // Legacy\n  'main',\n  'p',\n  'plaintext', // Legacy\n  'pre',\n  'xmp', // Legacy\n  // Sections and headings\n  'article',\n  'aside',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'hgroup',\n  'nav',\n  'section',\n  // Lists\n  'dir', // Legacy\n  'dd',\n  'dl',\n  'dt',\n  'menu',\n  'ol',\n  'ul'\n])\n\n// Implementation of the `innerText` getter:\n// <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n// Note that we act as if `node` is being rendered, and as if we’re a\n// CSS-supporting user agent.\nfunction toText(node) {\n  var children = node.children || []\n  var block = blockOrCaption(node)\n  var whiteSpace = inferWhiteSpace(node, {})\n  var index = -1\n  var results\n  var result\n  var value\n  var count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whiteSpace: whiteSpace,\n      breakBefore: true,\n      breakAfter: true\n    })\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      innerTextCollection(children[index], index, node, {\n        whiteSpace: whiteSpace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push(repeat('\\n', count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n// <https://html.spec.whatwg.org/#inner-text-collection-steps>\nfunction innerTextCollection(node, index, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, index, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whiteSpace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node, options)\n    ]\n  }\n\n  return []\n}\n\n// Collect an element.\nfunction collectElement(node, _, parent, options) {\n  // First we infer the `white-space` property.\n  var whiteSpace = inferWhiteSpace(node, options)\n  var children = node.children || []\n  var index = -1\n  var items = []\n  var prefix\n  var suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], index, node, {\n        whiteSpace: whiteSpace,\n        breakBefore: index ? null : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n// 4.  If node is a Text node, then for each CSS text box produced by node,\n//     in content order, compute the text of the box after application of the\n//     CSS `white-space` processing rules and `text-transform` rules, set\n//     items to the list of the resulting strings, and return items.\n//     The CSS `white-space` processing rules are slightly modified:\n//     collapsible spaces at the end of lines are always collapsed, but they\n//     are only removed if the line is the last line of the block, or it ends\n//     with a br element.\n//     Soft hyphens should be preserved.\n//\n//     Note: See `collectText` and `collectPreText`.\n//     Note: we don’t deal with `text-transform`, no element has that by\n//     default.\n//\n// See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\nfunction collectText(node, options) {\n  var value = String(node.value)\n  var lines = []\n  var result = []\n  var start = 0\n  var index = -1\n  var match\n  var end\n  var join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndcollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061c\\u200e\\u200f\\u202a-\\u202e\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n// 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n// 4.  Any collapsible space immediately following another collapsible\n//     space—even one outside the boundary of the inline containing that\n//     space, provided both spaces are within the same inline formatting\n//     context—is collapsed to have zero advance width. (It is invisible,\n//     but retains its soft wrap opportunity, if any.)\nfunction trimAndcollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  var result = []\n  var start = 0\n  var match\n  var end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n// We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\nfunction inferWhiteSpace(node, options) {\n  var props = node.properties || {}\n  var inherit = options.whiteSpace || 'normal'\n\n  switch (node.tagName) {\n    case 'listing':\n    case 'plaintext':\n    case 'xmp':\n      return 'pre'\n    case 'nobr':\n      return 'nowrap'\n    case 'pre':\n      return props.wrap ? 'pre-wrap' : 'pre'\n    case 'td':\n    case 'th':\n      return props.noWrap ? 'nowrap' : inherit\n    case 'textarea':\n      return 'pre-wrap'\n    default:\n      return inherit\n  }\n}\n\nfunction hidden(node) {\n  return (node.properties || {}).hidden\n}\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n"]},"metadata":{},"sourceType":"script"}